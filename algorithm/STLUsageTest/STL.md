# 标准模板库

标准模板库（standard template library,简写为STL）是用模板定义的一组类和函数。
STL定义了一组常用的数据结构，如向量，链表，集合，映射等，这些数据结构都被称为容器（container），为什么叫做容器呢？在我们的生活中，容器就是用来装一堆东西的。在这里，它们都用来管理一组元素，所以称之为容器。
STL定义了一组常用的算法，如排序，查找，集合计算（交集，并集）等。

## 容器

容器是什么？一个数组其实就是一个容器，管理某种类型的一个元素序列，每个元素都可按下标随机访问。数组作为容器的特点就是连续空间，固定大小，随机访问。缺点就是不容易在数组中间插入或者删除一个元素，因为会导致后面的元素逐个后移或前移。

STL容器是一组类模板，用来管理元素的序列。一个容器中的多个元素都具有相同类型，可以是基本类型，也可以是自定义类型。
容器可分为三大类：
序列容器（sequence container）、关联容器（associative container）和容器适配器（container adapter）
一、序列容器能维护插入元素的顺序，包括vector，deque,list等
二、关联容器按预定义顺序管理所插入元素，包括set,multiset,map,multimap
三、容器适配器是基于头等容器而建立的简单容器，包括stack，queue,priority_queue等。
序列容器与关联容器统称为头等容器（first-class container），意思是编程首选容器。

**各类容器特点**

| 容器名 | 中文名 | 头文件 | 特点 | 备注 |
| ------ | :----: | ------ | ---- | ---- |
vector                                  向量                                   <vecto>                            

 适合在序列尾端加入或删除元素：适合随机访问元素|随机访问按下标，下标范围为[0,size()-1];不合适中间插入或删除
deque                                  双端队列                            <deque>                             

适合在序列两端加入或删除元素；适合随机访问元素    全称为double-ended queue 不合适中间插入或者删除

list                                    链表                                       <list>

适合在序列中间插入或删除元素；适合双向遍历元素|双向链表实现，不适合随机访问

set                                   集合                                        <set>

各元素不重复；适合双向遍历|元素按值升序排序；各元素值唯一，称为键key;不适合随机访问

multiset                           多集                                        <set>

可重复元素；可双向遍历元素|元素按值升序排序，各元素值不唯一，称为键key;不适合随机访问

map                                映射单射                                 <map>

元素是对偶pair<key,value>一对一，多对一；键不重复；适合双向遍历|各元素按键升序排序；各元素的键是一个集合

multimap                       多射多值映射                            <map>

元素是对偶pair<key,value>一对多，多对多；键可重复；适合双向遍历|各元素按键生按升序排序；各元素的键是一个多集
stack                             栈                                              <stack>

先进后出LIFO；不支持迭代器|用成员函数来操作元素，基于deque实现

queue                            队列                                         <queue>

先进先出FIFO；不支持迭代器|用成员函数来操作元素；基于deque 实现

priority_queue               优先队列                                  <queue>

最高优先级先出；不支持迭代器|用成员函数来操作元素；基于vector实现；

STL还提供几种仿容器（near container）:
一、数组array和可变长数组valarray:任何一个数组都可以看作是一个容器，下标看作迭代器。
二、String字符串类型
三、bitset位集

## 迭代器
迭代器是什么？以数组为例，访问一个数组元素要使用下标，如a[i],则下标就是数组元素的迭代器。下标本质上是一个指针，指向要访问的那个元素。迭代器是用来访问容器中的元素的一种数据结构，是指针的抽象，但更安全，功能更强。
不论是范性思维或者STL的实际运用，迭代器（iterators）都扮演者重要角色。STL的中心思想在于：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一贴胶着剂将它们撮合在一起。

## 算法
STL算法包括&#60;algorithm>与&#60;numeric>

# vector

vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变。要换个大或小一点的房子，可以一切琐细得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬到新址，再把原来的空间释放还给系统。vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必担心空间不足而一开始就要求一个大块头的array了，我们可以安心使用vector，吃多少用多少。
**注意**：所谓扩充空间，不论多大，是配置新空间->数据移动->释放旧空间的过程，工程浩大。所谓动态增加大小，并不是在原空间之后连续新空间，因为无法保证原空间之后尚有可配置的空间，而是以原大小两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之一构造新元素，并释放原空间。因此对vector的任何操作，一旦引起空间空间重新配置，指向原vector的所有迭代器就都失效了。

# deque
deque是连续空间（至少逻辑上看来如此），连续线性空间总是令我们联想到array或vector。array无法成长，vector虽然可以成长，却只能向尾端成长，而且其所谓的成长是个假象，事实上是：一另觅更大空间，二将原有数据复制过去，三释放原空间三部曲。如果不是vector每次配置新空间是都有留下一个余裕，其成长假象所带来的带起将是相当高昂。

deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在deque的头部或尾部。便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置，复制，释放”的轮回，代价则是复杂的跌大气架构。受到分段连续线性空间的字面影响，我们可能以为deque的实现复杂程度和vector相比较虽不中亦不远矣，其实不然。主要因为，既曰分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。

deque采用一块所谓的map（注意：不是STL的map容器），作为主控，这里所谓map是一小块连续空间，其中每个元素（此处成为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，成为缓冲区。缓冲区才是deque的存储空间主体。

# list
相较于vector的连续线性空间，list就显得复杂许多，它的好处就是每次插入或删除一个元素，就配置或释放一个元素空间。因此对于空间的运用有绝对的精准，一点也不浪费。而且对于任何位置的元素的插入或元素移除，list永远是常数时间。list和vector是两个最常被使用的容器。什么时机在最适合使用哪一种容器，必须视元素的多寡，元素的构造复杂度（有无 non-traivial copy constructor ,non-trivial copy assugnmen operator），元素的存取行为的特性而定。list不在能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在。所谓的list迭代器正确的递增，递减，取值，成员取用的操作是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取用的是节点的成员。STL list 是一个双向链表（double linked-list），迭代器必须具备前移，后移的能力，所以list提供的是Bidirectional iterators. list 有一个重要性质：插入操作（insert）和接合操作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vector的插入操作造成记忆体（内存空间）重新配置，导致原有的跌大气全部失效。list的元素删除操作（erase），也只有指向被删除元素的那个迭代器失效，其他迭代器不受任何影响。

# map
标准的STL关联式容器分为set(集合）和map（映射表）两大类。以及这两大类的衍生体multiset（多建集合）和multimap（多键映射表）。这些容器的底层机制均是以RB-tree（红黑树）完成的。RB-tree也是一个独立容器，但并不对外开放使用。

map的特性是，所有元素都会根据元素的键值自动被排序。map的所有元素都是pair,同时拥有实值（value)和键值（key）。pair的第一元素被视为键值。第二元素被视为实值。map不允许两个元素拥有相同的键值。我们可以通过map的迭代器改变map的元素内容吗？如果想要修正元素的键值，答案是不行，因为map元素的键值关系到map元素的排序规则。任意改变map元素键值，将会严重破坏map组织。但是如果想要修正元素的实值，答案是可以的，因为map元素的实值并不影响map的元素的排列规则。因此，map iterators 既不是一种constant iterator,也不是一种mutable iterators。

map拥有和list相同的某些性质，当客户端对它进行元素新增操作（insert）或删除操作（erase）时，操作之前的所有迭代器，在操作完成之后都依然有效。当然，被删除的那个元素的迭代器必然是个例外。由于RB-tree是一种平衡二叉搜索树，自动排序的效果很是不错，所以标准的STL map 即以RB-tree为底层机制。又由于map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的map的操作行为，都只是转调用RB-tree的操作行为而已。

multimap 的特性以及用法与map完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的insert_equal()而非。

# set
标准的STL关联式容器分为set(集合）和map（映射表）两大类。以及这两大类的衍生体multiset（多建集合）和multimap（多键映射表）。这些容器的底层机制均是以RB-tree（红黑树）完成的。RB-tree也是一个独立容器，但并不对外开放使用。set 的特性是，所有元素都会根据元素的键值自动被排序，set的元素不像map那样可以同时拥有实（value）和键值（key）,set元素的键值就是实值，实值就是键值，set不允许两个元素有相同的键值。

我们可以通过set的迭代器改变set的元素值吗？不行，因为set的元素值就是其键值，关系到set元素的排列规则。如果任意改变set的元素值，会严重破坏set组织。set&#60;T>::iterator 被定义为底层RB-tree的const_iterator,杜绝写入操作，换句话说，set iterators 是一种constant iterator（相对于 mutable iterator）。set拥有和list相同的某些性质，当客户端对它进行元素新增操作（insert）或删除操作（erase）时，操作之前的所有迭代器，在操作完成之后都依然有效。当然，被删除的那个元素的迭代器必然是个例外。

由于RB-tree是一种平衡二叉搜索树，自动排序的效果很是不错，所以标准的STL set 即以RB-tree为底层机制。又由于map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set的操作行为，都只是转调用RB-tree的操作行为而已。multiset 的特性以及用法与set完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()。

# priority_queue
顾名思义，priority_queque是一个拥有权值观念的queque,它允许加入新元素，移除旧元素，审视新元素值等功能。由于这是一个queque,所以只允许在底端键入元素，并从顶端取出元素，除此之外别无其他存取元素途径。priority_queque带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列（通常权值以实值表示）。权值最高者，排在最前。缺省情况下priority_queque系利用一个max_heap完成，后者是一个vector表现得complete binary tree.max_heap 可以满足priority_queque所需要的“依照权值高低自动递减排序”的特性。

由于priority_queque完全以底部容器为根据，再加上heap处理规则，所以实现非常简单。缺省情况下是以vector为底部容器。由于priority_queque系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，成为（配接器，适配器）adapter,因此SLT priority_queque 往往不被归类为container（容器），而被归类为container adapter。priority_queque的所有元素，进出都有一定规则，只有queqeu顶端的元素（权值最高者），才有机会被外界取用。priority_queque不提供遍历功能，也不提供迭代器。

# stack
stack是一种先进后出（First In Last Out,FILO）的数据结构。它只有一个出口，stack允许新增元素，移除元素，取得最顶端元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素，换而言之，stack不允许有遍历行为。
将元素推入stack的操作称为push,将元素推出stack的操作称为pop.

以某种既有容器作为底部结构，将其接口改变，使之符合“先进后出”的特性，形成一个stack，是很容易做到的。deque是双向开口的数据结构，若以deque为底部结构并封闭其头端开口，便轻而易举地形成了一个stack。以deque作为缺省情况下的stack底部结构，stack的实现很简单。

由于stack系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，成为（配接器，适配器）adapter,因此SLT stack 往往不被归类为container（容器），而被归类为container adapter。stack所有元素的进出都必须符合“先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。stack不提供走访功能，也不提供迭代器。除了deque之外，list也是双向开口的数据结构。因为若以list底部结构并封闭其头端开口，一样能够轻易形成一个stack。